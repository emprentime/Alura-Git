SISTEMAS DE CONTROLE DE VERSÕES:

O que são (e para que servem) sistemas de controle de versões e como eles podem ajudar o nosso fluxo de desenvolvimento?

Nos ajudam a manter um histórico de alterações;
Nos ajudam a ter controle sobre cada alteração no código;
Nos ajudam para que uma alteração de determinada pessoa não influencie na alteração realizada por outra;
Etc.

COMANDOS PARA SEREM APLICADOS NO GIT BASH:


cd - Para navegar entre pastas.
ls - Para verificr quais arquivos estão na pasta.
Ctrl + L ou clear- Para limpar a tela.
touch + nome do arquivo - Para criarmos um arquivo.
mkdir + nome da pasta - Para criarmos uma pasta
cd + nome da pasta - Para acessarmos uma pasta


Antes de qualquer interação com o git, precisamos informar quem somos para que ele armazene corretamente os dados do autor de cada uma das alterações no código.

git config --local user.name "Seu nome aqui"
git config --local user.email "seu@email.aqui"

Como fazemos para o Git passar a enxergar determinada pasta como um repositório e a observar as mudanças em seus arquivos?

O git init inicializa um repositório no diretório em que o comando for executado. A partir deste comando, o Git poderá gerenciar as modificações realizadas nos arquivos.

git init - Para inicializar um repositório Git.

O comando abaixo mostra o estado do nosso repositório, ou seja, quais arquivos foram alterados, ou não:

git status


Para monitorarmos um arquivo que nunca foi editado e salvo pelo Git, utilizaremos o comando git add + o nome do arquivo, exemplo git add index.html. Se tivéssemos vários arquivos, não precisaríamos colocar seus nomes um a um, bastando git add . para que todos os arquivos da pasta atual sejam monitorados.

git add nome_do_arquivo - Para monitorarmos um arquivo específico.
git add . - Para monitorarmos todos os arquivos do diretório.


Changes to committed - "mudanças a serem commitadas", ou salvas, enviadas.

O comando git rm + o nome do arquivo, exemplo git rm index.html serve para remover o arquivo e para que o mesmo deixe de ser monitorado.

git rm nome_do_arquivo - Para removermos o arquivo do monitoramento.


O comando git commit -m "", serve para passarmos uma mensagem de commit e por isso usamos o parâmetro -m.

git commit -m "Acrescente aqui uma pequena descrição do que foi modificado"

A boa prática pede para colocarmos mensagens descritivas, evitando que fiquem muito grandes.

Seguem algumas definições interessantes:

HEAD: Estado atual do nosso código, ou seja, onde o Git os colocou.
Working tree: Local onde os arquivos realmente estão sendo armazenados e .
index: Local onde o Git armazena o que será commitado, ou seja, o local entre a working tree e o repositório Git em si.

Link: <https://git-scm.com/book/pt-br/v2/Fundamentos-de-Git-Gravando-Altera%C3%A7%C3%B5es-em-Seu-Reposit%C3%B3rio.



Para verificarmos o histórico de alterações, cada mensagem de commits feita, o andamento do nosso projeto e etc, o comando a se utilizar é git log, que nos mostrará diversas informações, sendo a primeira delas um hash do commit.

git log

hash do commit = uma identificação única de cada commit, isto é, não existem dois commits com o mesmo hash.


Abaixo o  resultado do git log:

$ git log

commit df46b2d2e17a8b1583d732b1430b15bc208ecf39 (HEAD -> master)
Author: Marcio Roberto Leite da Silva <emprentime@gmail.com>
Date:   Sat Oct 30 16:48:24 2021 -0300

    Acento adicionado no curso de Integração Contínua

Explicação:

O comando git log nos mostrará diversas informações, sendo a primeira delas um hash do commit, uma identificação única de cada commit, isto é, não existem dois commits com o mesmo hash.

Tendo esse hash, conseguiremos realizar algumas manipulações. A informação seguinte se refere ao branch, ou "ramo" em que o commit se encontra. Neste caso, verificamos que há HEAD e master. Isto quer dizer que HEAD é o local onde nos encontramos, no nosso código, onde acontecem as alterações que fizermos, e que estamos em um ramo denominado master.

Além disso, temos a autoria do commit, e-mail configurado, data de commit, e mensagem.

O comando git config --local serve para configurarmos algo para um projeto específico, ou, para a máquina toda, podemos utilizar o git config --global.

Poderemos visualizar as configurações salvas por meio do comando git config user.name, ou git config user.email.

Alternativas ao git log:

git log --oneline - Nos permite visualizar todos os commits, sendo que cada uma ocupa uma única linha: 
git log -p - Se quisermos mais informações como as alterações do commit

Existe uma infinidade de formatos que podemos usar como filtros para mostrar nosso histórico, e em git log cheatsheet há vários delas. Como exemplo, testaremos git log --pretty="format:%H", comando que nos traz apenas o hash. O comando git log --pretty="format:%h %s", por sua vez, traz o hash resumido seguido pela mensagem do commit. Assim, podemos gerar o histórico da nossa aplicação em formatos personalizados.

Arquivo .gitignore:

Existe um arquivo especial do Git, chamado .gitignore, e todas as linhas que estiverem nele serão lidas e ignoradas pelo Git. Se temos um arquivo denominado ignorar_este_arquivo que queremos que seja ignorado, por exemplo, basta o incluirmos em .gitignore, digitando ignorar_este_arquivo simplesmente. Da mesma forma, se tivéssemos uma pasta teste, incluiríamos teste/, em uma nova linha.

Porém, antes de conferirmos isto com git status, precisaremos adicioná-los, com git add .gitignore, por exemplo, e git commit -m "Adicionando .gitignore".

Quando commitar:

Devemos gerar um commit sempre que a nossa base de código está em um estado do qual gostaríamos de nos lembrar. Nunca devemos ter commits de códigos que não funcionam, mas também não é interessante deixar para commitar apenas no final de uma feature.

Essa pode ser uma discussão sem fim e cada empresa ou equipe pode seguir uma estratégia diferente. Estude sobre o assunto, entenda o que faz mais sentido para você e sua equipe e seja feliz!

O comando abaixo serve para definirmos um repositório Git, onde todos os membros da equipe o acessarão para compartilhar suas mudanças. Com este comando nós criamos um repositório que não terá a working tree, ou seja, não conterá uma cópia dos nossos arquivos. Como o repositório servirá apenas como servidor, para que outros membros da equipe sincronizem seus trabalhos, poupamos espaço de armazenamento desta forma.

git init --bare

git clone - Traz um repositório remoto para o nosso computador, criando um repositório local.

git push [repositorio] master - Para enviarmos as alterações para o repositório remoto
Desta forma, nós enviamos as alterações em nosso branch master para o repositório remoto. Basta substituir [repositorio] pelo nome que demos ao repositório ao adicioná-lo. Já para trazer os dados que estiverem no repositório remoto, podemos utilizar o git pull [repositorio] master.

GitHub:

Com o GitHub, podemos ter repositórios remotos públicos e privados gratuitos para armazenar e compartilhar o código dos nossos projetos.


git remote rename origin local - Para renomear o repositório local da outra pessoa de "origin" para "local";

git push - Para enviar as suas modificações para o seu servidor

git pull - Para baixar as modificações;

O que é um branch?

Uma ramificação no git é um ponteiro para as alterações feitas nos arquivos do projeto. É útil em situações nas quais você deseja adicionar um novo recurso ou corrigir um erro, gerando uma nova ramificação garantindo que o código instável não seja mesclado nos arquivos do projeto principal. Depois de concluir a atualização dos códigos da ramificação, você pode mesclar a ramificação com a principal, geralmente chamada de master (main). https://receitasdecodigo.com.br/devops/git-o-que-e-um-branch

Git branch nome da branch - Cria uma nova branch
git checkout nome da branch - Para mudarmos de branch
git checkout -b nome da branch - Cria uma nova branch e já muda para ela

Como podemos fazer o merge da branch titulo para a branch master?

git checkout master e git merge titulo

Desta forma colocaremos o HEAD na branch master, ou seja, faremos com que o nosso código esteja no estado que o deixamos com o último commit na master. Depois, uniremos o trabalho da branch titulo com a branch atual (master).

O que é o git rebase?

Rebasing é o processo de mover ou combinar uma sequência de commits para um novo commit base. O rebasing é mais útil e melhor visualizado no contexto do fluxo de trabalho de ramificação de recurso. 

A partir da perspectiva de conteúdo, o rebase é o processo de alterar a base da ramificação do commit para outra, fazendo parecer como se você criou a ramificação a partir de um commit diferente. De um jeito intrínseco, o Git realiza isso criando novos commits e aplicando-os à base especificada. É muito importante entender que, mesmo que a ramificação pareça a mesma, ela é composta de commits novos completos.

Uso:

O principal motivo para fazer o rebase é manter um histórico de projeto linear. Por exemplo, considere uma situação em que a ramificação principal progrediu desde que você começou a trabalhar em uma ramificação de recurso. Você quer colocar as atualizações mais recentes da ramificação principal na ramificação de recurso, mas também quer o histórico da ramificação limpo, para que pareça que você esteve trabalhando com a ramificação principal mais recente. Assim você tem o benefício posterior do merge limpo da ramificação de recurso de volta para a ramificação principal. Por que é interessante manter um "histórico limpo"? Os benefícios de ter um histórico limpo ficam tangíveis ao realizar operações do Git para investigar a introdução de uma regressão. Um cenário mais realista seria:

Um bug foi identificado na ramificação principal. Um recurso que estava funcionando bem agora está com falha.
Um desenvolvedor examina o histórico da ramificação principal usando git log. Por causa do "histórico limpo", o desenvolvedor é capaz de analisar rápido o histórico do projeto.
O desenvolvedor agora não consegue identificar quando o bug foi introduzido usando git log, então, ele executa git bisect.
Como o histórico do git está limpo, o git bisect tem um conjunto refinado de commits para comparar ao observar a regressão. O desenvolvedor encontra logo o commit que introduziu o bug e consegue agir de acordo. https://www.atlassian.com/br/git/tutorials/rewriting-history/git-rebase


Qual a diferença entre os comandos rebase e merge?

O merge junta os trabalhos e gera um merge commit. O rebase aplica os commits de outra branch na branch atual.

Com isso, evitamos os commits de merge.